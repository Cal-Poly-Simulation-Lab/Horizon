using Microsoft.VisualStudio.TestPlatform.TestHost;
using Horizon;
using Utilities;
using NUnit.Framework.Internal;
using HSFScheduler;
using HSFSystem;
using MissionElements;
using System.Runtime.InteropServices.Marshalling;
using log4net;
using System.Security.Cryptography.X509Certificates;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Transactions;
using UserModel;

namespace HSFSchedulerUnitTest
{
    [TestFixture]
    public class SystemSchedulerConstructorUnitTest : SchedulerUnitTest
    {
        private string? DefaultSimInputFile = "SchedulerTestSimulationInput.json";
        private string? DefaultModelInputFile;
        private string? DefaultTaskInputFile;
        private SystemClass? testSystem;
        private Stack<MissionElements.Task>? testTasks;


        [SetUp]
        public void SetupDefaultExhaustiveTest()
        {
            // Optional: Log the resolved path for debugging
            TestContext.WriteLine($"Test directory resolved to: {CurrentTestDir}");

            // // Use the existing test files for the 1 asset, 3 tasks scenario
            SimInputFile = Path.Combine(ProjectTestDir, "SchedulerTestSimulationInput.json"); // Bulletproof path to default simulation input
            TaskInputFile = Path.Combine(CurrentTestDir, "DefaultThreeTaskInput.json");
            ModelInputFile = Path.Combine(CurrentTestDir, "DefaultOneAssetModelInput.json");

            // Load the program to get the system and tasks & Create the system and tasks for testing      
            BuildProgram();

        }

        private void BuildProgram()
        {
            // Load the program to get the system and tasks
            program = HorizonLoadHelper(SimInputFile, TaskInputFile, ModelInputFile);

            //Schedules = this.scheduler.GenerateSchedules(SimSystem, SystemTasks, InitialSysState);

            // Create (a copy of) the system and tasks for testing -- These are created by the program, under program.SimSystem and program.SystemTasks
            testSystem = new SystemClass(program.AssetList, program.SubList, program.ConstraintsList, program.SystemUniverse);
            testTasks = new Stack<MissionElements.Task>(program.SystemTasks);

            // SimParameters are read-only, use the values from the loaded program
            double simEnd = SimParameters.SimEndSeconds;
            double simStep = SimParameters.SimStepSeconds;
            double simStart = SimParameters.SimStartSeconds;
            
            Scheduler.InitializeEmptySchedule(systemSchedules, program.InitialSysState); // Create the empty schedule and add it to the systemSchedules list
            scheduleCombos = Scheduler.GenerateExhaustiveSystemSchedules(testSystem, testTasks, scheduleCombos, simStart, simEnd);
            systemSchedules = program.scheduler.CropToMaxSchedules(systemSchedules, Scheduler.emptySchedule);
        }

        [Test, Order(1)]
        public void ConstructorTest_WithFullSimAccess()
        {
            // This is a test of the constructor where schedule combos are generated by default and have access windows for the entire
            // simulation. In this case, we expect event start/end times to be on the fundamental time step, as well as the task start/end
            // times when coming out of the constructor. 


            double currentTime = 0.0;
            double endTime = 60.0;

            // Loop through all systemschedules that will be generated (skipping CanAddTasks logic here-- just to test the constructor)
            int k = 0; 
            foreach(var oldSystemSchedule in systemSchedules)
            {
                //potentialSystemSchedules.Add(new SystemSchedule( new StateHistory(oldSystemSchedule.AllStates)));
                foreach (var newAccessTaskStack in scheduleCombos)
                {
                }
            }


            // Assert
            Assert.Multiple(() =>
            {
               
            });

        }
        
    }
}